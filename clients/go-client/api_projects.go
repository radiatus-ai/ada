/*
Platform API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 0.1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// ProjectsAPIService ProjectsAPI service
type ProjectsAPIService service

type ApiCreateAdaV1ProjectsPostRequest struct {
	ctx context.Context
	ApiService *ProjectsAPIService
	projectCreate *ProjectCreate
	xAdaToken *string
}

func (r ApiCreateAdaV1ProjectsPostRequest) ProjectCreate(projectCreate ProjectCreate) ApiCreateAdaV1ProjectsPostRequest {
	r.projectCreate = &projectCreate
	return r
}

func (r ApiCreateAdaV1ProjectsPostRequest) XAdaToken(xAdaToken string) ApiCreateAdaV1ProjectsPostRequest {
	r.xAdaToken = &xAdaToken
	return r
}

func (r ApiCreateAdaV1ProjectsPostRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.CreateAdaV1ProjectsPostExecute(r)
}

/*
CreateAdaV1ProjectsPost Create

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateAdaV1ProjectsPostRequest
*/
func (a *ProjectsAPIService) CreateAdaV1ProjectsPost(ctx context.Context) ApiCreateAdaV1ProjectsPostRequest {
	return ApiCreateAdaV1ProjectsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return interface{}
func (a *ProjectsAPIService) CreateAdaV1ProjectsPostExecute(r ApiCreateAdaV1ProjectsPostRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectsAPIService.CreateAdaV1ProjectsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ada/v1/projects"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.projectCreate == nil {
		return localVarReturnValue, nil, reportError("projectCreate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAdaToken != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-ada-token", r.xAdaToken, "")
	}
	// body params
	localVarPostBody = r.projectCreate
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateChatAdaV1ProjectsProjectIdChatsPostRequest struct {
	ctx context.Context
	ApiService *ProjectsAPIService
	projectId int32
	chatCreate *ChatCreate
	xAdaToken *string
}

func (r ApiCreateChatAdaV1ProjectsProjectIdChatsPostRequest) ChatCreate(chatCreate ChatCreate) ApiCreateChatAdaV1ProjectsProjectIdChatsPostRequest {
	r.chatCreate = &chatCreate
	return r
}

func (r ApiCreateChatAdaV1ProjectsProjectIdChatsPostRequest) XAdaToken(xAdaToken string) ApiCreateChatAdaV1ProjectsProjectIdChatsPostRequest {
	r.xAdaToken = &xAdaToken
	return r
}

func (r ApiCreateChatAdaV1ProjectsProjectIdChatsPostRequest) Execute() (*Chat, *http.Response, error) {
	return r.ApiService.CreateChatAdaV1ProjectsProjectIdChatsPostExecute(r)
}

/*
CreateChatAdaV1ProjectsProjectIdChatsPost Create Chat

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId
 @return ApiCreateChatAdaV1ProjectsProjectIdChatsPostRequest
*/
func (a *ProjectsAPIService) CreateChatAdaV1ProjectsProjectIdChatsPost(ctx context.Context, projectId int32) ApiCreateChatAdaV1ProjectsProjectIdChatsPostRequest {
	return ApiCreateChatAdaV1ProjectsProjectIdChatsPostRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return Chat
func (a *ProjectsAPIService) CreateChatAdaV1ProjectsProjectIdChatsPostExecute(r ApiCreateChatAdaV1ProjectsProjectIdChatsPostRequest) (*Chat, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Chat
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectsAPIService.CreateChatAdaV1ProjectsProjectIdChatsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ada/v1/projects/{project_id}/chats"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatCreate == nil {
		return localVarReturnValue, nil, reportError("chatCreate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAdaToken != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-ada-token", r.xAdaToken, "")
	}
	// body params
	localVarPostBody = r.chatCreate
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateChatMessageAdaV1ProjectsProjectIdChatsChatIdMessagesPostRequest struct {
	ctx context.Context
	ApiService *ProjectsAPIService
	projectId int32
	chatId int32
	chatMessageCreate *ChatMessageCreate
	xAdaToken *string
}

func (r ApiCreateChatMessageAdaV1ProjectsProjectIdChatsChatIdMessagesPostRequest) ChatMessageCreate(chatMessageCreate ChatMessageCreate) ApiCreateChatMessageAdaV1ProjectsProjectIdChatsChatIdMessagesPostRequest {
	r.chatMessageCreate = &chatMessageCreate
	return r
}

func (r ApiCreateChatMessageAdaV1ProjectsProjectIdChatsChatIdMessagesPostRequest) XAdaToken(xAdaToken string) ApiCreateChatMessageAdaV1ProjectsProjectIdChatsChatIdMessagesPostRequest {
	r.xAdaToken = &xAdaToken
	return r
}

func (r ApiCreateChatMessageAdaV1ProjectsProjectIdChatsChatIdMessagesPostRequest) Execute() (*ChatMessage, *http.Response, error) {
	return r.ApiService.CreateChatMessageAdaV1ProjectsProjectIdChatsChatIdMessagesPostExecute(r)
}

/*
CreateChatMessageAdaV1ProjectsProjectIdChatsChatIdMessagesPost Create Chat Message

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId
 @param chatId
 @return ApiCreateChatMessageAdaV1ProjectsProjectIdChatsChatIdMessagesPostRequest
*/
func (a *ProjectsAPIService) CreateChatMessageAdaV1ProjectsProjectIdChatsChatIdMessagesPost(ctx context.Context, projectId int32, chatId int32) ApiCreateChatMessageAdaV1ProjectsProjectIdChatsChatIdMessagesPostRequest {
	return ApiCreateChatMessageAdaV1ProjectsProjectIdChatsChatIdMessagesPostRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		chatId: chatId,
	}
}

// Execute executes the request
//  @return ChatMessage
func (a *ProjectsAPIService) CreateChatMessageAdaV1ProjectsProjectIdChatsChatIdMessagesPostExecute(r ApiCreateChatMessageAdaV1ProjectsProjectIdChatsChatIdMessagesPostRequest) (*ChatMessage, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChatMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectsAPIService.CreateChatMessageAdaV1ProjectsProjectIdChatsChatIdMessagesPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ada/v1/projects/{project_id}/chats/{chat_id}/messages"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"chat_id"+"}", url.PathEscape(parameterValueToString(r.chatId, "chatId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatMessageCreate == nil {
		return localVarReturnValue, nil, reportError("chatMessageCreate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAdaToken != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-ada-token", r.xAdaToken, "")
	}
	// body params
	localVarPostBody = r.chatMessageCreate
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteChatAdaV1ProjectsProjectIdChatsChatIdDeleteRequest struct {
	ctx context.Context
	ApiService *ProjectsAPIService
	projectId int32
	chatId int32
	xAdaToken *string
}

func (r ApiDeleteChatAdaV1ProjectsProjectIdChatsChatIdDeleteRequest) XAdaToken(xAdaToken string) ApiDeleteChatAdaV1ProjectsProjectIdChatsChatIdDeleteRequest {
	r.xAdaToken = &xAdaToken
	return r
}

func (r ApiDeleteChatAdaV1ProjectsProjectIdChatsChatIdDeleteRequest) Execute() (*Chat, *http.Response, error) {
	return r.ApiService.DeleteChatAdaV1ProjectsProjectIdChatsChatIdDeleteExecute(r)
}

/*
DeleteChatAdaV1ProjectsProjectIdChatsChatIdDelete Delete Chat

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId
 @param chatId
 @return ApiDeleteChatAdaV1ProjectsProjectIdChatsChatIdDeleteRequest
*/
func (a *ProjectsAPIService) DeleteChatAdaV1ProjectsProjectIdChatsChatIdDelete(ctx context.Context, projectId int32, chatId int32) ApiDeleteChatAdaV1ProjectsProjectIdChatsChatIdDeleteRequest {
	return ApiDeleteChatAdaV1ProjectsProjectIdChatsChatIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		chatId: chatId,
	}
}

// Execute executes the request
//  @return Chat
func (a *ProjectsAPIService) DeleteChatAdaV1ProjectsProjectIdChatsChatIdDeleteExecute(r ApiDeleteChatAdaV1ProjectsProjectIdChatsChatIdDeleteRequest) (*Chat, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Chat
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectsAPIService.DeleteChatAdaV1ProjectsProjectIdChatsChatIdDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ada/v1/projects/{project_id}/chats/{chat_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"chat_id"+"}", url.PathEscape(parameterValueToString(r.chatId, "chatId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAdaToken != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-ada-token", r.xAdaToken, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteChatMessageAdaV1ProjectsProjectIdChatsChatIdMessagesMessageIdDeleteRequest struct {
	ctx context.Context
	ApiService *ProjectsAPIService
	projectId int32
	chatId int32
	messageId int32
	xAdaToken *string
}

func (r ApiDeleteChatMessageAdaV1ProjectsProjectIdChatsChatIdMessagesMessageIdDeleteRequest) XAdaToken(xAdaToken string) ApiDeleteChatMessageAdaV1ProjectsProjectIdChatsChatIdMessagesMessageIdDeleteRequest {
	r.xAdaToken = &xAdaToken
	return r
}

func (r ApiDeleteChatMessageAdaV1ProjectsProjectIdChatsChatIdMessagesMessageIdDeleteRequest) Execute() (*ChatMessage, *http.Response, error) {
	return r.ApiService.DeleteChatMessageAdaV1ProjectsProjectIdChatsChatIdMessagesMessageIdDeleteExecute(r)
}

/*
DeleteChatMessageAdaV1ProjectsProjectIdChatsChatIdMessagesMessageIdDelete Delete Chat Message

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId
 @param chatId
 @param messageId
 @return ApiDeleteChatMessageAdaV1ProjectsProjectIdChatsChatIdMessagesMessageIdDeleteRequest
*/
func (a *ProjectsAPIService) DeleteChatMessageAdaV1ProjectsProjectIdChatsChatIdMessagesMessageIdDelete(ctx context.Context, projectId int32, chatId int32, messageId int32) ApiDeleteChatMessageAdaV1ProjectsProjectIdChatsChatIdMessagesMessageIdDeleteRequest {
	return ApiDeleteChatMessageAdaV1ProjectsProjectIdChatsChatIdMessagesMessageIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		chatId: chatId,
		messageId: messageId,
	}
}

// Execute executes the request
//  @return ChatMessage
func (a *ProjectsAPIService) DeleteChatMessageAdaV1ProjectsProjectIdChatsChatIdMessagesMessageIdDeleteExecute(r ApiDeleteChatMessageAdaV1ProjectsProjectIdChatsChatIdMessagesMessageIdDeleteRequest) (*ChatMessage, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChatMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectsAPIService.DeleteChatMessageAdaV1ProjectsProjectIdChatsChatIdMessagesMessageIdDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ada/v1/projects/{project_id}/chats/{chat_id}/messages/{message_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"chat_id"+"}", url.PathEscape(parameterValueToString(r.chatId, "chatId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"message_id"+"}", url.PathEscape(parameterValueToString(r.messageId, "messageId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAdaToken != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-ada-token", r.xAdaToken, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListProjectsAdaV1ProjectsGetRequest struct {
	ctx context.Context
	ApiService *ProjectsAPIService
	skip *int32
	limit *int32
	xAdaToken *string
}

func (r ApiListProjectsAdaV1ProjectsGetRequest) Skip(skip int32) ApiListProjectsAdaV1ProjectsGetRequest {
	r.skip = &skip
	return r
}

func (r ApiListProjectsAdaV1ProjectsGetRequest) Limit(limit int32) ApiListProjectsAdaV1ProjectsGetRequest {
	r.limit = &limit
	return r
}

func (r ApiListProjectsAdaV1ProjectsGetRequest) XAdaToken(xAdaToken string) ApiListProjectsAdaV1ProjectsGetRequest {
	r.xAdaToken = &xAdaToken
	return r
}

func (r ApiListProjectsAdaV1ProjectsGetRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.ListProjectsAdaV1ProjectsGetExecute(r)
}

/*
ListProjectsAdaV1ProjectsGet List Projects

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListProjectsAdaV1ProjectsGetRequest
*/
func (a *ProjectsAPIService) ListProjectsAdaV1ProjectsGet(ctx context.Context) ApiListProjectsAdaV1ProjectsGetRequest {
	return ApiListProjectsAdaV1ProjectsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return interface{}
func (a *ProjectsAPIService) ListProjectsAdaV1ProjectsGetExecute(r ApiListProjectsAdaV1ProjectsGetRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectsAPIService.ListProjectsAdaV1ProjectsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ada/v1/projects"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.skip != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skip", r.skip, "")
	} else {
		var defaultValue int32 = 0
		r.skip = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	} else {
		var defaultValue int32 = 100
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAdaToken != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-ada-token", r.xAdaToken, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReadChatAdaV1ProjectsProjectIdChatsChatIdGetRequest struct {
	ctx context.Context
	ApiService *ProjectsAPIService
	projectId int32
	chatId int32
	xAdaToken *string
}

func (r ApiReadChatAdaV1ProjectsProjectIdChatsChatIdGetRequest) XAdaToken(xAdaToken string) ApiReadChatAdaV1ProjectsProjectIdChatsChatIdGetRequest {
	r.xAdaToken = &xAdaToken
	return r
}

func (r ApiReadChatAdaV1ProjectsProjectIdChatsChatIdGetRequest) Execute() (*Chat, *http.Response, error) {
	return r.ApiService.ReadChatAdaV1ProjectsProjectIdChatsChatIdGetExecute(r)
}

/*
ReadChatAdaV1ProjectsProjectIdChatsChatIdGet Read Chat

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId
 @param chatId
 @return ApiReadChatAdaV1ProjectsProjectIdChatsChatIdGetRequest
*/
func (a *ProjectsAPIService) ReadChatAdaV1ProjectsProjectIdChatsChatIdGet(ctx context.Context, projectId int32, chatId int32) ApiReadChatAdaV1ProjectsProjectIdChatsChatIdGetRequest {
	return ApiReadChatAdaV1ProjectsProjectIdChatsChatIdGetRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		chatId: chatId,
	}
}

// Execute executes the request
//  @return Chat
func (a *ProjectsAPIService) ReadChatAdaV1ProjectsProjectIdChatsChatIdGetExecute(r ApiReadChatAdaV1ProjectsProjectIdChatsChatIdGetRequest) (*Chat, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Chat
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectsAPIService.ReadChatAdaV1ProjectsProjectIdChatsChatIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ada/v1/projects/{project_id}/chats/{chat_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"chat_id"+"}", url.PathEscape(parameterValueToString(r.chatId, "chatId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAdaToken != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-ada-token", r.xAdaToken, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReadChatMessagesAdaV1ProjectsProjectIdChatsChatIdMessagesGetRequest struct {
	ctx context.Context
	ApiService *ProjectsAPIService
	projectId int32
	chatId int32
	skip *int32
	limit *int32
	xAdaToken *string
}

func (r ApiReadChatMessagesAdaV1ProjectsProjectIdChatsChatIdMessagesGetRequest) Skip(skip int32) ApiReadChatMessagesAdaV1ProjectsProjectIdChatsChatIdMessagesGetRequest {
	r.skip = &skip
	return r
}

func (r ApiReadChatMessagesAdaV1ProjectsProjectIdChatsChatIdMessagesGetRequest) Limit(limit int32) ApiReadChatMessagesAdaV1ProjectsProjectIdChatsChatIdMessagesGetRequest {
	r.limit = &limit
	return r
}

func (r ApiReadChatMessagesAdaV1ProjectsProjectIdChatsChatIdMessagesGetRequest) XAdaToken(xAdaToken string) ApiReadChatMessagesAdaV1ProjectsProjectIdChatsChatIdMessagesGetRequest {
	r.xAdaToken = &xAdaToken
	return r
}

func (r ApiReadChatMessagesAdaV1ProjectsProjectIdChatsChatIdMessagesGetRequest) Execute() ([]ChatMessage, *http.Response, error) {
	return r.ApiService.ReadChatMessagesAdaV1ProjectsProjectIdChatsChatIdMessagesGetExecute(r)
}

/*
ReadChatMessagesAdaV1ProjectsProjectIdChatsChatIdMessagesGet Read Chat Messages

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId
 @param chatId
 @return ApiReadChatMessagesAdaV1ProjectsProjectIdChatsChatIdMessagesGetRequest
*/
func (a *ProjectsAPIService) ReadChatMessagesAdaV1ProjectsProjectIdChatsChatIdMessagesGet(ctx context.Context, projectId int32, chatId int32) ApiReadChatMessagesAdaV1ProjectsProjectIdChatsChatIdMessagesGetRequest {
	return ApiReadChatMessagesAdaV1ProjectsProjectIdChatsChatIdMessagesGetRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		chatId: chatId,
	}
}

// Execute executes the request
//  @return []ChatMessage
func (a *ProjectsAPIService) ReadChatMessagesAdaV1ProjectsProjectIdChatsChatIdMessagesGetExecute(r ApiReadChatMessagesAdaV1ProjectsProjectIdChatsChatIdMessagesGetRequest) ([]ChatMessage, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ChatMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectsAPIService.ReadChatMessagesAdaV1ProjectsProjectIdChatsChatIdMessagesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ada/v1/projects/{project_id}/chats/{chat_id}/messages"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"chat_id"+"}", url.PathEscape(parameterValueToString(r.chatId, "chatId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.skip != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skip", r.skip, "")
	} else {
		var defaultValue int32 = 0
		r.skip = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	} else {
		var defaultValue int32 = 100
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAdaToken != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-ada-token", r.xAdaToken, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReadChatsAdaV1ProjectsProjectIdChatsGetRequest struct {
	ctx context.Context
	ApiService *ProjectsAPIService
	projectId int32
	skip *int32
	limit *int32
	xAdaToken *string
}

func (r ApiReadChatsAdaV1ProjectsProjectIdChatsGetRequest) Skip(skip int32) ApiReadChatsAdaV1ProjectsProjectIdChatsGetRequest {
	r.skip = &skip
	return r
}

func (r ApiReadChatsAdaV1ProjectsProjectIdChatsGetRequest) Limit(limit int32) ApiReadChatsAdaV1ProjectsProjectIdChatsGetRequest {
	r.limit = &limit
	return r
}

func (r ApiReadChatsAdaV1ProjectsProjectIdChatsGetRequest) XAdaToken(xAdaToken string) ApiReadChatsAdaV1ProjectsProjectIdChatsGetRequest {
	r.xAdaToken = &xAdaToken
	return r
}

func (r ApiReadChatsAdaV1ProjectsProjectIdChatsGetRequest) Execute() ([]Chat, *http.Response, error) {
	return r.ApiService.ReadChatsAdaV1ProjectsProjectIdChatsGetExecute(r)
}

/*
ReadChatsAdaV1ProjectsProjectIdChatsGet Read Chats

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId
 @return ApiReadChatsAdaV1ProjectsProjectIdChatsGetRequest
*/
func (a *ProjectsAPIService) ReadChatsAdaV1ProjectsProjectIdChatsGet(ctx context.Context, projectId int32) ApiReadChatsAdaV1ProjectsProjectIdChatsGetRequest {
	return ApiReadChatsAdaV1ProjectsProjectIdChatsGetRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return []Chat
func (a *ProjectsAPIService) ReadChatsAdaV1ProjectsProjectIdChatsGetExecute(r ApiReadChatsAdaV1ProjectsProjectIdChatsGetRequest) ([]Chat, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Chat
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectsAPIService.ReadChatsAdaV1ProjectsProjectIdChatsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ada/v1/projects/{project_id}/chats"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.skip != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skip", r.skip, "")
	} else {
		var defaultValue int32 = 0
		r.skip = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	} else {
		var defaultValue int32 = 100
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAdaToken != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-ada-token", r.xAdaToken, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateChatAdaV1ProjectsProjectIdChatsChatIdPutRequest struct {
	ctx context.Context
	ApiService *ProjectsAPIService
	projectId int32
	chatId int32
	chatUpdate *ChatUpdate
	xAdaToken *string
}

func (r ApiUpdateChatAdaV1ProjectsProjectIdChatsChatIdPutRequest) ChatUpdate(chatUpdate ChatUpdate) ApiUpdateChatAdaV1ProjectsProjectIdChatsChatIdPutRequest {
	r.chatUpdate = &chatUpdate
	return r
}

func (r ApiUpdateChatAdaV1ProjectsProjectIdChatsChatIdPutRequest) XAdaToken(xAdaToken string) ApiUpdateChatAdaV1ProjectsProjectIdChatsChatIdPutRequest {
	r.xAdaToken = &xAdaToken
	return r
}

func (r ApiUpdateChatAdaV1ProjectsProjectIdChatsChatIdPutRequest) Execute() (*Chat, *http.Response, error) {
	return r.ApiService.UpdateChatAdaV1ProjectsProjectIdChatsChatIdPutExecute(r)
}

/*
UpdateChatAdaV1ProjectsProjectIdChatsChatIdPut Update Chat

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId
 @param chatId
 @return ApiUpdateChatAdaV1ProjectsProjectIdChatsChatIdPutRequest
*/
func (a *ProjectsAPIService) UpdateChatAdaV1ProjectsProjectIdChatsChatIdPut(ctx context.Context, projectId int32, chatId int32) ApiUpdateChatAdaV1ProjectsProjectIdChatsChatIdPutRequest {
	return ApiUpdateChatAdaV1ProjectsProjectIdChatsChatIdPutRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		chatId: chatId,
	}
}

// Execute executes the request
//  @return Chat
func (a *ProjectsAPIService) UpdateChatAdaV1ProjectsProjectIdChatsChatIdPutExecute(r ApiUpdateChatAdaV1ProjectsProjectIdChatsChatIdPutRequest) (*Chat, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Chat
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectsAPIService.UpdateChatAdaV1ProjectsProjectIdChatsChatIdPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ada/v1/projects/{project_id}/chats/{chat_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"chat_id"+"}", url.PathEscape(parameterValueToString(r.chatId, "chatId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatUpdate == nil {
		return localVarReturnValue, nil, reportError("chatUpdate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAdaToken != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-ada-token", r.xAdaToken, "")
	}
	// body params
	localVarPostBody = r.chatUpdate
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateChatMessageAdaV1ProjectsProjectIdChatsChatIdMessagesMessageIdPutRequest struct {
	ctx context.Context
	ApiService *ProjectsAPIService
	projectId int32
	chatId int32
	messageId int32
	chatMessageUpdate *ChatMessageUpdate
	xAdaToken *string
}

func (r ApiUpdateChatMessageAdaV1ProjectsProjectIdChatsChatIdMessagesMessageIdPutRequest) ChatMessageUpdate(chatMessageUpdate ChatMessageUpdate) ApiUpdateChatMessageAdaV1ProjectsProjectIdChatsChatIdMessagesMessageIdPutRequest {
	r.chatMessageUpdate = &chatMessageUpdate
	return r
}

func (r ApiUpdateChatMessageAdaV1ProjectsProjectIdChatsChatIdMessagesMessageIdPutRequest) XAdaToken(xAdaToken string) ApiUpdateChatMessageAdaV1ProjectsProjectIdChatsChatIdMessagesMessageIdPutRequest {
	r.xAdaToken = &xAdaToken
	return r
}

func (r ApiUpdateChatMessageAdaV1ProjectsProjectIdChatsChatIdMessagesMessageIdPutRequest) Execute() (*ChatMessage, *http.Response, error) {
	return r.ApiService.UpdateChatMessageAdaV1ProjectsProjectIdChatsChatIdMessagesMessageIdPutExecute(r)
}

/*
UpdateChatMessageAdaV1ProjectsProjectIdChatsChatIdMessagesMessageIdPut Update Chat Message

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId
 @param chatId
 @param messageId
 @return ApiUpdateChatMessageAdaV1ProjectsProjectIdChatsChatIdMessagesMessageIdPutRequest
*/
func (a *ProjectsAPIService) UpdateChatMessageAdaV1ProjectsProjectIdChatsChatIdMessagesMessageIdPut(ctx context.Context, projectId int32, chatId int32, messageId int32) ApiUpdateChatMessageAdaV1ProjectsProjectIdChatsChatIdMessagesMessageIdPutRequest {
	return ApiUpdateChatMessageAdaV1ProjectsProjectIdChatsChatIdMessagesMessageIdPutRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		chatId: chatId,
		messageId: messageId,
	}
}

// Execute executes the request
//  @return ChatMessage
func (a *ProjectsAPIService) UpdateChatMessageAdaV1ProjectsProjectIdChatsChatIdMessagesMessageIdPutExecute(r ApiUpdateChatMessageAdaV1ProjectsProjectIdChatsChatIdMessagesMessageIdPutRequest) (*ChatMessage, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChatMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectsAPIService.UpdateChatMessageAdaV1ProjectsProjectIdChatsChatIdMessagesMessageIdPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ada/v1/projects/{project_id}/chats/{chat_id}/messages/{message_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"chat_id"+"}", url.PathEscape(parameterValueToString(r.chatId, "chatId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"message_id"+"}", url.PathEscape(parameterValueToString(r.messageId, "messageId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatMessageUpdate == nil {
		return localVarReturnValue, nil, reportError("chatMessageUpdate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAdaToken != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-ada-token", r.xAdaToken, "")
	}
	// body params
	localVarPostBody = r.chatMessageUpdate
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
